(ns funlisp.eval-simple
  (:gen-class))

;; A simple example of a Lisp interpreter.

; This will be our main evaluation function:
(declare eval-exp) ; note: returns a pair [result environment]

; Same as eval-exp, but throws away the environment, returning just the result:
(declare result)

;; Helper functions:
(defn starts-with? [l el] (= (first l) el)) ; does collection l start with el?
(defn third [coll] (nth coll 2)) ; third element in a collection
(defn fourth [coll] (nth coll 3)) ; ...

(defn eval-if
  "Used for if forms: (if predicate consequent alternate).
  (Means the same as 'IF predicate THEN consequent ELSE alternate' in
  a standard non-Lisp language)."
  [predicate consequent alternate env]
  (if (result predicate env)
    (result consequent env)
    (result alternate env)))

(defn def-in-env
  "Set the variable vname to have the value of expression exp as its value
  in environment env."
  [vname exp env]
  (assoc env ; note: env is a [variable name] -> [value] map, so we assoc
   vname
   (result exp env)))

(defn var-lookup
  "Lookup variable vname in environment env, returning nil if it doesn't exist"
  [vname env]
  (env vname)) ; map lookup

(defn function
  "Return the data structure we will use to represent a function with
  a certain body, environment, and argument names"
  [body env arg-names]
  {:function? true
   :body body
   :env env ; -> the environment the function was defined in
   ; (we store the environment so the language supports closures)
   :arg-names arg-names}) ; a simple map with keywords as keys

(defn macro
  "Return the data structure we will use to represent a macro."
  [body arg-names]
  {:macro? true
   :body body
   :arg-names arg-names})

(defn eval-exp-list
  "Evaluates a list of expressions in sequence, with the start environment env,
  but with any changes to the environment made by one expression being passed
  on to the remaining expressions in the sequence. Returns a [value environment]
  pair like eval-exp."
  [exps env]
  (cond
    (empty? exps) ['nil env]
    (empty? (rest exps)) (eval-exp (first exps) env)
    true (eval-exp-list (rest exps)
                        (second ; <- this selects the new environment
                         (eval-exp (first exps) env)))))

(defn result-exp-list
  "Like eval-exp-list, but returns only the result (throwing away
  the environment)."
  [exps env]
  (first (eval-exp-list exps env)))

(defn apply-fn
  "Applies a function represented by a data structure func (as generated by
  the function function) to a sequence of argument values arg-vals, in
  environment env."
  [func arg-vals env]
  (result-exp-list
   ; ^ evaluate all expressions in the function body, returning value of last
   (func :body) ; a list of expressions
   (merge
    (merge env ; merge the calling env. and function env. (for closures)
           (func :env)) ; function environment takes priority if conflicts
    ; Link arg names and values: [a b c] [1 2 3] -> the map {a 1, b 2, c 3}
    (zipmap (func :arg-names) arg-vals))))

(defn recursive-replace
  "Traverses a collection (e.g. nested list) coll, replacing any non-collection
  that's a key of map rmap with the value it maps to in rmap."
  [rmap coll]
  (map (fn [el] (if (coll? el)
                  (recursive-replace rmap el)
                  (if (nil? (rmap el))
                    el
                    (rmap el))))
       coll))

(defn macro-expand
  "Take a macro structure as that generated by the macro function, a set of
  args (not arg values, but the unevaluated code itself), and return the code
  that the macro expands to."
  [macro args]
  (recursive-replace (zipmap (macro :arg-names) args)
                     (macro :body)))


(defn eval-unquoted
  "Traverses exp, replacing things of the form (UQT an-exp) with
  (result an-exp env). (Used to implement quasiquote (QQT), which in turn
  helps the user write macros)"
  [exp env]
  (cond
    (not (coll? exp)) exp
    (starts-with? exp 'UQT) (result (second exp) env)
    :else
    (map (fn [el] (eval-unquoted el env))
         exp)))

;; Example use of eval-exp: (eval-exp '(+ 1 1) {}) -> [2 {}],
;; (eval-exp '(def x 4) {}) -> [nil {x 4}].
;; Hint: use eval-exp-list if you want to easily make a bunch of definitions
;; and then use them, for example:
;; (eval-exp-list '((def increment-one (lambda (x) (+ x 1)))
;;                  (increment-one 41))
;; -> [42, <env>]
(defn eval-exp
  "Returns [value new-environment], where value is the value of evaluating
  expression exp in environment env, "
  [exp env]
  (cond
    (or (true? exp) (false? exp) (nil? exp)) [exp env] ; t/f/nil -> do nothing
    (string? exp) [exp env] ; string -> do nothing
    (number? exp) [exp env] ; number -> do nothing
    ; symbol -> assume it's a variable and return its value:
    (symbol? exp) [(var-lookup exp env) env]
    ; the quote function:
    ; (a Lisp-specific thing to return without evaluating, e.g. (QT x) -> x)
    (starts-with? exp 'QT) [(second exp) env]
    ; the quasiquote function (a quote that's escapable with UQT):
    (starts-with? exp 'QQT) [(eval-unquoted (second exp) env) env]
    ; if:
    (starts-with? exp 'if) [(eval-if (second exp) (third exp) (fourth exp) env)
                            env] ; <- environment still unchanged
    ; def
    (starts-with? exp 'def)
    ['nil ; <- return nothing
     (def-in-env ; <- environment object changes
       (second exp) ; name
       (third exp) ; expression name should be bound to
       env)]
    ; +
    (starts-with? exp '+)
    [(+ (result (second exp) env)
        (result (third exp) env))
     env]
    ; =
    (starts-with? exp '=)
    [(= (result (second exp) env)
        (result (third exp) env))
     env]
    ; first (get the first item of a list)
    (starts-with? exp 'first)
    [(result (second exp) env)
     env]
    ; rest (get all but the first item of a list)
    (starts-with? exp 'rest)
    [(result (second exp) env)
     env]
    ; cons (add an element to the front of a list)
    (starts-with? exp 'cons)
    [(conj (result (third exp) env)  ; note Clojure cons argument order
           (result (second exp) env)); (first list, then thing to add)
     env]
    ; print
    (starts-with? exp 'print)
    (do
      (println (result (second exp) env))
      ['nil env])
    ; lambda, for creating a function, e.g. (lambda (x y) (+ x y)) for x -> x+y
    (starts-with? exp 'lambda)
    [(function (rest (rest exp)) ; function body, ((+ x y)) above
               env ; store definition environment for use in closures
               (second exp)) ; argument names, (x y) above
     env]
    ; macros:
    (starts-with? exp 'macro)
    [(macro (rest (rest exp))
            (second exp))
     env]
    :else ; function/macro application (tried if none of the above match)
    (let [thing (result (first exp) env)]
      (cond
        ; FUNCTION APPLICATION:
        (thing :function?)
        [(apply-fn
          thing
          (map (fn [aexp] (result aexp env)) ; call-by-value:
               (rest exp)) ; evaluate each argument in the calling environment
          env)             ; and then pass this list of values to the function
         env]  ; <- environment unchanged (!)
        ; MACRO EXPANSION:
        (thing :macro?)
        (eval-exp ; <- run the code the macro expands into
         (result-exp-list ; <- expand the macro to get the code to run
          (macro-expand thing (rest exp))
          env)
         env)
        ; else should throw an error, but error supporting not implemented ...
        :else 'EVAL-ERROR))))

(defn result
  "Evaluates expression exp in environment env, then returns only the result
  (throwing away the environment)."
  [exp env]
  (first (eval-exp exp env)))
