(ns funlisp.redlisp-compilation.eval-cps
  (:gen-class))

;; eval_1, converted to CPS
;; (Continuation Passing Style)

(defn id [x] x)

; This will be our main evaluation function:
(declare eval-exp) ; note: returns a pair [result environment]

; Same as eval-exp, but throws away the environment, returning just the result:
(declare result)

;; Helper functions:
(defn map-cps
  ([f-cps l cnt acc]
   (if (empty? l)
     (cnt acc)
     (f-cps (first l)
            (fn [fx]
              (map-cps f-cps (rest l) cnt
                       (conj acc
                             fx))))))
  ([f-cps l cnt]
   (map-cps f-cps l cnt [])))
(defn starts-with? [l el] (= (first l) el)) ; does collection l start with el?
(defn third [coll] (nth coll 2)) ; third element in a collection
(defn fourth [coll] (nth coll 3)) ; ...
(defn var-lookup
  "Lookup variable vname in environment env, returning nil if it doesn't exist"
  [vname env]
  (env vname)) ; map lookup
(defn match-args
  "Takes a list of argument names and a list of argument values
   and matches them up"
  [arg-names arg-vals]
  (zipmap arg-names arg-vals))
(defn function
  "Return the data structure we will use to represent a function with
    a certain body, environment, and argument names"
  [body env arg-names]
  {:function? true
   :body body
   :env env ; -> the environment the function was defined in
   ; (we store the environment so the language supports closures)
   :args arg-names})
(defn cons-pair
  "Return the data structure for a cons pair."
  [a b]
  {:cons? true
   :car a ; car/cdr are the standard Lisp terms
   :cdr b})

(defn eval-if
  [predicate consequent alternate env cnt]
  (result predicate env
          (fn [r]
            (if r
              (result consequent env cnt)
              (result alternate  env cnt)))))

(defn def-in-env
  "Set the variable vname to have the value of expression exp as its value
  in environment env."
  [vname exp env cnt]
  (result exp env
          (fn [r]
            (cnt (assoc env vname r)))))

(defn eval-exp-list
  "Evaluates a list of expressions in sequence, with the start environment env,
  but with any changes to the environment made by one expression being passed
  on to the remaining expressions in the sequence. Returns a [value environment]
  pair like eval-exp."
  ([exps env cnt]
  (cond
    (empty? exps) (cnt ['nil env])
    (empty? (rest exps)) (eval-exp (first exps) env cnt)
    true (eval-exp-list (rest exps)
                        (second ; <- this selects the new environment
                                (eval-exp (first exps) env cnt))
                        cnt)))
  ([exps env] ; -> this is what the REPL uses
   (eval-exp-list exps env id)))

(defn result-exp-list
  "Like eval-exp-list, but returns only the result (throwing away
  the environment)."
  [exps env cnt]
  (eval-exp-list exps env
                 (fn [r]
                   (cnt (first r)))))

(defn apply-fn
  "Applies a function represented by a data structure func (as generated by
  the function function) to a sequence of argument values arg-vals, in
  environment env."
  [func arg-vals env cnt]
  (result-exp-list
   (func :body) ; a list of expressions
   (merge
    (func :env) ; LEXICAL SCOPING instead of dynamic scoping as above
    (match-args (func :args) arg-vals))
   cnt))

(defn eval-exp
  "Returns [value new-environment], where value is the value of evaluating
  expression exp in environment env, "
  [exp env cnt]
  (cond
    (or (true? exp) (false? exp) (nil? exp)) (cnt [exp env]) ; t/f/nil -> do nothing
    (number? exp) (cnt [exp env]) ; number -> do nothing
    ; symbol -> assume it's a variable and return its value:
    (symbol? exp) (cnt [(var-lookup exp env) env])
    ; if:
    (starts-with? exp 'if) (eval-if (second exp) (third exp) (fourth exp) env
                                    (fn [r]
                                      (cnt [r env])))
    ; def
    (starts-with? exp 'def)
    (def-in-env (second exp) (third exp) env
      (fn [env]
        (cnt ['nil env])))
    ; +
    (starts-with? exp '+)
    (result (second exp) env
            (fn [r1]
              (result (third exp) env
                      (fn [r2]
                        (cnt [(+ r1 r2) env])))))
    ; =
    (starts-with? exp '=)
    (result (second exp) env
            (fn [r1]
              (result (third exp) env
                      (fn [r2]
                        (cnt [(= r1 r2) env])))))
    ; cons (add an element to the front of a list)
    (starts-with? exp 'cons)
    (result (second exp) env
            (fn [car]
              (result (third exp) env
                      (fn [cdr]
                        (cnt [(cons-pair car cdr) env])))))
    ; first
    (starts-with? exp 'first)
    (result (second exp) env
            (fn [r]
              (cnt [(r :car) env])))
    ; rest
    (starts-with? exp 'rest)
    (result (second exp) env
            (fn [r]
              (cnt [(r :cdr) env])))
    ; lambda, for creating a function, e.g. (lambda (x y) (+ x y)) for x -> x+y
    (starts-with? exp 'lambda)
    (cnt [(function (rest (rest exp)) ; function body, ((+ x y)) above
                    env ; store definition environment for use in closures
                    (second exp)) ; argument names, (x y) above
          env])
    :else ; functions
    (result (first exp) env
            (fn [thing]
              (if (thing :function?)
                (map-cps (fn [aexp cnt]
                           (result aexp env cnt))
                         (rest exp)
                         (fn [mapped-args]
                           (apply-fn
                            thing
                            mapped-args
                            env
                            (fn [r]
                              (cnt [r env])))))
                'EVAL-ERROR)))))

(defn result
  "Evaluates expression exp in environment env, then returns only the result
  (throwing away the environment)."
  [exp env cnt]
  (eval-exp exp env
            (fn [[res env]]
              (cnt res))))
