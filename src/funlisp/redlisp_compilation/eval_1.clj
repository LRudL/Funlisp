(ns funlisp.redlisp-compilation.eval-1
  (:gen-class))

;; A simplified (macroless) Lisp evaluator;
;; starting point for compiler derivation

; This will be our main evaluation function:
(declare eval-exp) ; note: returns a pair [result environment]

; Same as eval-exp, but throws away the environment, returning just the result:
(declare result)

;; Helper functions:
(defn starts-with? [l el] (= (first l) el)) ; does collection l start with el?
(defn third [coll] (nth coll 2)) ; third element in a collection
(defn fourth [coll] (nth coll 3)) ; ...

(defn eval-if
  "Used for if forms: (if predicate consequent alternate).
  (Means the same as 'IF predicate THEN consequent ELSE alternate' in
  a standard non-Lisp language)."
  [predicate consequent alternate env]
  (if (result predicate env)
    (result consequent env)
    (result alternate env)))

(defn def-in-env
  "Set the variable vname to have the value of expression exp as its value
  in environment env."
  [vname exp env]
  (assoc env ; note: env is a [variable name] -> [value] map, so we assoc
   vname
   (result exp env)))

(defn var-lookup
  "Lookup variable vname in environment env, returning nil if it doesn't exist"
  [vname env]
  (env vname)) ; map lookup

(defn match-args
  "Takes a list of argument names and a list of argument values
   and matches them up"
  [arg-names arg-vals]
  (zipmap arg-names arg-vals))

(defn function
  "Return the data structure we will use to represent a function with
  a certain body, environment, and argument names"
  [body env arg-names]
  {:function? true
   :body body
   :env env ; -> the environment the function was defined in
   ; (we store the environment so the language supports closures)
   :args arg-names})

(defn cons-pair
  "Return the data structure for a cons pair."
  [a b]
  {:cons? true
   :car a ; car/cdr are the standard Lisp terms
   :cdr b})

(defn eval-exp-list
  "Evaluates a list of expressions in sequence, with the start environment env,
  but with any changes to the environment made by one expression being passed
  on to the remaining expressions in the sequence. Returns a [value environment]
  pair like eval-exp."
  [exps env]
  (cond
    (empty? exps) ['nil env]
    (empty? (rest exps)) (eval-exp (first exps) env)
    true (eval-exp-list (rest exps)
                        (second ; <- this selects the new environment
                                (eval-exp (first exps) env)))))

(defn result-exp-list
  "Like eval-exp-list, but returns only the result (throwing away
  the environment)."
  [exps env]
  (first (eval-exp-list exps env)))

(defn apply-fn
  "Applies a function represented by a data structure func (as generated by
  the function function) to a sequence of argument values arg-vals, in
  environment env."
  [func arg-vals env]
  (result-exp-list
   ; ^ evaluate all expressions in the function body, returning value of last
   (func :body) ; a list of expressions
   (merge
    ;(merge env ; merge the calling env. and function env. (for closures)
    ;       (func :env)) ; function environment takes priority if conflicts
    (func :env) ; LEXICAL SCOPING instead of dynamic scoping as above
    ; Link arg names and values (see args-parse and match-args for details):
    (match-args (func :args) arg-vals))))

;; Example use of eval-exp: (eval-exp '(+ 1 1) {}) -> [2 {}],
;; (eval-exp '(def x 4) {}) -> [nil {x 4}].
;; Hint: use eval-exp-list if you want to easily make a bunch of definitions
;; and then use them, for example:
;; (eval-exp-list '((def increment-one (lambda (x) (+ x 1)))
;;                  (increment-one 41))
;; -> [42, <env>]
(defn eval-exp
  "Returns [value new-environment], where value is the value of evaluating
  expression exp in environment env, "
  [exp env]
  (cond
    (or (true? exp) (false? exp) (nil? exp)) [exp env] ; t/f/nil -> do nothing
    (number? exp) [exp env] ; number -> do nothing
    ; symbol -> assume it's a variable and return its value:
    (symbol? exp) [(var-lookup exp env) env]
    ; if:
    (starts-with? exp 'if) [(eval-if (second exp) (third exp) (fourth exp) env)
                            env] ; <- environment still unchanged
    ; def
    (starts-with? exp 'def)
    ['nil ; <- return nothing
     (def-in-env ; <- environment object changes
       (second exp) ; name
       (third exp) ; expression name should be bound to
       env)]
    ; +
    (starts-with? exp '+)
    [(+ (result (second exp) env)
        (result (third exp) env))
     env]
    ; =
    (starts-with? exp '=)
    [(= (result (second exp) env)
        (result (third exp) env))
     env]
    ; cons (add an element to the front of a list)
    (starts-with? exp 'cons)
    [(cons-pair (result (second exp) env)  ; note Clojure cons argument order
                (result (third exp) env)); (first list, then thing to add)
     env]
    ; first
    (starts-with? exp 'first)
    [((result (second exp)) :car)
     env]
    ; rest
    (starts-with? exp 'rest)
    [((result (second exp)) :cdr)
     env]
    ; lambda, for creating a function, e.g. (lambda (x y) (+ x y)) for x -> x+y
    (starts-with? exp 'lambda)
    [(function (rest (rest exp)) ; function body, ((+ x y)) above
               env ; store definition environment for use in closures
               (second exp)) ; argument names, (x y) above
     env]
    :else ; functions/macros
    (let [thing (result (first exp) env)]
      (cond
        ; FUNCTION APPLICATION:
        (thing :function?)
        [(apply-fn
          thing
          (map (fn [aexp] (result aexp env)) ; call-by-value:
               (rest exp)) ; evaluate each argument in the calling environment
          env)             ; and then pass this list of values to the function
         env]  ; <- environment unchanged (!)
        ; else should throw an error, but error supporting not implemented ...
        :else 'EVAL-ERROR))))

(defn result
  "Evaluates expression exp in environment env, then returns only the result
  (throwing away the environment)."
  [exp env]
  (first (eval-exp exp env)))
